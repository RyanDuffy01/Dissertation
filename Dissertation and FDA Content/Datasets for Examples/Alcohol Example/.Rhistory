All_Countries_UnE <- bind_rows(Scot_UnE,Eng_UnE,Wales_UnE,NI_UnE)
All_Countries_UnE_Wide <- pivot_wider(All_Countries_UnE,names_from = Country,values_from = Unemployment_Rate)
ggplot(All_Countries_UnE,aes(x=Year,y=Unemployment_Rate,col=Country))+
geom_point()+
ylab("Unemployment Rate (%)") +
xlim(c(2000,2022))
basis_mortality_rates <- create.bspline.basis(rangeval=range(Years),breaks=Years,norder=4)
# Libraries
library(tidyverse) # ggplot(.)
library(mgcv) # gam(.)
library(splines) # bs(.) (B-splines)
library(MuMIn) # dredge(.)
library(fields) # quilt.plot(.)
library(lawstat) # runs.test(.)
setwd("~/MT5756 - Advanced Data Analysis/Practical 6")
# Read dataset
HornsRev <- read.csv("HornsRev.csv")
# Set Impact as factor
HornsRev <- HornsRev %>%
mutate(Impact=as.factor(Impact))
# Fits a GAM
PRS <- mgcv::gam(Nhat ~ s(XPos) + s(YPos) + s(Depth) + Impact,
data=HornsRev, family=quasipoisson, offset=log(Area))
PRS_Non_Quas <-  PRS <- mgcv::gam(Nhat ~ s(XPos) + s(YPos) + s(Depth) + Impact,
data=HornsRev, family=poisson, offset=log(Area))
PRS$scale
PRS$scale
PRS$scale.estimated
# Fits a GAM
PRS <- mgcv::gam(Nhat ~ s(XPos) + s(YPos) + s(Depth) + Impact,
data=HornsRev, family="quasipoisson", offset=log(Area))
PRS$scale.estimated
PRS$scale
# Fits a GAM
PRS <- mgcv::gam(Nhat ~ s(XPos) + s(YPos) + s(Depth) + Impact,
data=HornsRev, family="quasipoisson", offset=log(Area))
summary(PRS)
summary(PRS)
plot(PRS)
plot(PRS, shade=T, residuals=T, ylim=c(-10,10))
termplot(PRS)
gam.check(PRS)
PRS$scale
PRS_Non_Quas <-  mgcv::gam(Nhat ~ s(XPos) + s(YPos) + s(Depth) + Impact,
data=HornsRev, family="poisson", offset=log(Area))
dredged_model_choice <- dredge(PRS_Non_Quas, rank="QAIC",
chat=PRS$scale)
options(na.action="na.fail")
dredged_model_choice <- dredge(PRS_Non_Quas, rank="QAIC",
chat=PRS$scale)
head(dredged_model_choice)
# Fits a GAM with a spline for depth of with 20 knots
PRS_B <- stats::update(PRS, .~. -s(Depth) + splines::bs(Depth, knots=20))
summary(PRS_B)
summary(PRS)
plot(PRS_B)
plot(PRS)
stats::termplot(PRS_B, se=T)
PRS_Int <- mgcv::gam(Nhat ~ s(XPos, by=Impact) + s(YPos) +
s(Depth) + Impact,
data=df, family=quasipoisson, offset=log(Area))
PRS_Int <- mgcv::gam(Nhat ~ s(XPos, by=Impact) + s(YPos) +
s(Depth) + Impact,
data=HornsRev, family=quasipoisson, offset=log(Area))
summary(PRS_Int)
HornsRevGrid <- read.csv("HornsRevPredictionData.csv")
library(fields) # quilt.plot(.)
par(mfrow=c(2,2))
# Loop across all phases
for (Impact in c(0,1))
{
bWant <- HornsRev$Impact %in% Impact # a boolean specifying phase
fields::quilt.plot(HornsRevGrid$XPos[bWant],
HornsRevGrid$YPos[bWant],
fitted(PRS)[bWant],
nrow=25, ncol=60,
zlim=range(fitted(PRS)),
main=paste0("Impact ", Impact))
}
HornsRev$Impact %in% Impact
library(fields) # quilt.plot(.)
par(mfrow=c(2,2))
# Loop across all phases
for (Impact in c(0,1))
{
bWant <- HornsRevGrid$Impact %in% Impact # a boolean specifying phase
fields::quilt.plot(HornsRevGrid$XPos[bWant],
HornsRevGrid$YPos[bWant],
fitted(PRS)[bWant],
nrow=25, ncol=60,
zlim=range(fitted(PRS)),
main=paste0("Impact ", Impact))
}
library(fields) # quilt.plot(.)
par(mfrow=c(2,2))
# Loop across all phases
for (Impact in c(0,1))
{
bWant <- HornsRevGrid$Impact %in% Impact # a boolean specifying phase
fields::quilt.plot(HornsRevGrid$XPos[bWant],
HornsRevGrid$YPos[bWant],
predict(PRS,newdata = HornsRevGrid)[bWant],
nrow=25, ncol=60,
zlim=range(predict(PRS,newdata = HornsRevGrid)),
main=paste0("Impact ", Impact))
}
library(fields) # quilt.plot(.)
par(mfrow=c(1,2\))
par(mfrow=c(1,2))
# Loop across all phases
for (Impact in c(0,1))
{
bWant <- HornsRevGrid$Impact %in% Impact # a boolean specifying phase
fields::quilt.plot(HornsRevGrid$XPos[bWant],
HornsRevGrid$YPos[bWant],
predict(PRS,newdata = HornsRevGrid)[bWant],
nrow=25, ncol=60,
zlim=range(predict(PRS,newdata = HornsRevGrid)),
main=paste0("Impact ", Impact))
}
HornsRevGrid$Impact %in% Impact
HornsRevGrid$XPos[bWant]
predict(PRS,newdata = HornsRevGrid)[bWant]
HornsRevGrid <- read.csv("HornsRevPredictionData.csv")
library(fields) # quilt.plot(.)
par(mfrow=c(1,2))
# Loop across all phases
for (Impact in c(0,1))
{
bWant <- HornsRevGrid$Impact %in% Impact # a boolean specifying phase
fields::quilt.plot(HornsRevGrid$XPos[bWant],
HornsRevGrid$YPos[bWant],
predict(PRS,newdata = HornsRevGrid)[bWant],
zlim=range(predict(PRS,newdata = HornsRevGrid)),
main=paste0("Impact ", Impact))
}
HornsRevGrid <- read.csv("HornsRevPredictionData.csv")
library(fields) # quilt.plot(.)
par(mfrow=c(1,2))
# Loop across all phases
for (Impact in c(0,1))
{
bWant <- HornsRevGrid$Impact %in% Impact # a boolean specifying phase
fields::quilt.plot(HornsRevGrid$XPos[bWant],
HornsRevGrid$YPos[bWant],
predict(PRS_Int,newdata = HornsRevGrid)[bWant],
zlim=range(predict(PRS_Int,newdata = HornsRevGrid)),
main=paste0("Impact ", Impact))
}
library(fields) # quilt.plot(.)
par(mfrow=c(1,2))
# Loop across all phases
for (Impact in c(0,1))
{
bWant <- HornsRevGrid$Impact %in% Impact # a boolean specifying phase
fields::quilt.plot(HornsRevGrid$XPos[bWant],
HornsRevGrid$YPos[bWant],
predict(PRS_Int,newdata = HornsRevGrid,type = "response")[bWant],
zlim=range(predict(PRS_Int,newdata = HornsRevGrid,type="response")),
main=paste0("Impact ", Impact))
}
library(fields) # quilt.plot(.)
par(mfrow=c(1,2))
# Loop across all phases
for (Impact in c(0,1))
{
bWant <- HornsRevGrid$Impact %in% Impact # a boolean specifying phase
fields::quilt.plot(HornsRevGrid$XPos[bWant],
HornsRevGrid$YPos[bWant],
predict(PRS,newdata = HornsRevGrid,type = "response")[bWant],
zlim=range(predict(PRS,newdata = HornsRevGrid,type="response")),
main=paste0("Impact ", Impact))
}
summary(PRS)
library(fda)
library(tidyverse)
setwd("~/Dissertation/Dissertation and FDA Content/Datasets for Examples/Alcohol Example")
#### Load Data ####
mortality_rates_wide <- read_csv("Alcohol Mortality Rates Per Country.csv", skip = 6)
mortality_rates_long <- pivot_longer(mortality_rates_wide,values_to="MortalityRate",cols=2:5,names_to = "Country")
ggplot(mortality_rates_long,aes(x=Year,y=MortalityRate,col=Country))+
geom_point()+
ylab("Age-standardised death rates per 100,000 people")
Years <- unique(mortality_rates_long$Year)
#### Function Fitting ####
basis_mortality_rates <- create.bspline.basis(range(Years),
breaks=Years,
norder=4)
observation_matrix <- data.matrix(mortality_rates_wide[,c(-1)])
GCV_func <- function(log_lambda,basis,observations,time_points,penalty){
lambda <- 10^log_lambda
fd_par_obj <- fdPar(basis,penalty,lambda)
smoothbasisobj <- smooth.basis(time_points,observations,fd_par_obj)
return(sum(smoothbasisobj$gcv))
}
optimised_function <- optimise(GCV_func,lower=0,upper=10,basis=basis_mortality_rates,observations=observation_matrix,time_points=Years,penalty=2)
minimum_log_lambda <- optimised_function$minimum
minimum_lambda <- 10^minimum_log_lambda
fd_par_obj <- fdPar(basis_mortality_rates,2,minimum_lambda)
sample_of_functions <- smooth.basis(Years,observation_matrix,fd_par_obj)$fd
sample_of_functions$fdnames$time <- "Years"
sample_of_functions$fdnames$values <- "Mortality Rate"
year_mesh <- seq(2001,2020,0.01)
eval_df <- as.data.frame(eval.fd(year_mesh,sample_of_functions)) %>%
mutate(Year=year_mesh)
eval_df_long <- pivot_longer(eval_df,names_to = "Country",values_to = "MortalityRate",cols=1:4)
# gives visualisation of sample of functions
ggplot(mortality_rates_long,aes(x=Year,y=MortalityRate,col=Country))+
geom_point()+
ylab("Age-standardised death rates per 100,000 people")
ggplot(eval_df_long,aes(x=Year,y=MortalityRate,col=Country))+
geom_line()+
geom_point(data=mortality_rates_long,aes(x=Year,y=MortalityRate,col=Country),inherit.aes = FALSE,alpha=0.2)+
ylab("Age-standardised death rates per 100,000 people")
#### Checking Residuals ####
shap_test <- function(vector){
shapiro.test(vector)$p.value
}
residuals_matrix <- eval.fd(Years,sample_of_functions)-observation_matrix
apply(t(residuals_matrix),1,shap_test)
#### Summary Functions ####
#gives visualisation of the mean of this sample
mean_func <- mean.fd(sample_of_functions)
mean_plot_df <- data.frame(Year=year_mesh,mean=eval.fd(mean_func,year_mesh))
ggplot(eval_df_long,aes(x=Year,y=MortalityRate,col=Country))+
geom_line()+
geom_point(data=mortality_rates_long,aes(x=Year,y=MortalityRate,col=Country),inherit.aes = FALSE,alpha=0.2)+
geom_line(data=mean_plot_df,aes(x=Year,y=mean),inherit.aes = FALSE) +
ylab("Age-standardised death rates per 100,000 people")
#gives standard deviation of this sample
sd_func <- sd.fd(sample_of_functions)
sd_plot_df <- data.frame(Year=year_mesh,stand_dev=eval.fd(sd_func,year_mesh))
ggplot(sd_plot_df,aes(x=Year,y=stand_dev)) +
geom_line() +
ylab("Standard Deviation in Curves")
#### fPCA of Data ####
principle_components_of_sample <- pca.fd(sample_of_functions)
func_eval <- eval.fd(year_mesh,principle_components_of_sample$harmonics)
PC_DF <- data.frame(
Year = year_mesh,
PC_1 = func_eval[,1],
PC_2 = func_eval[,2]
)
ggplot(PC_DF,aes(x=Year,y=PC_1))+
geom_line() +
ylab("Principal Component Function 1")+
ggtitle(paste0("PC 1 - Explains ",100*principle_components_of_sample$varprop[1],"% Of Variation"))
ggplot(PC_DF,aes(x=Year,y=PC_2))+
geom_line() +
ylab("Principal Component Function 2")+
ggtitle(paste0("PC 2 - Explains ",100*principle_components_of_sample$varprop[2],"% Of Variation"))
scores_df <- data.frame(
PC_1 = principle_components_of_sample$scores[,1],
PC_2 = principle_components_of_sample$scores[,2],
Country=colnames(observation_matrix)
)
ggplot(scores_df,aes(x=PC_1,y=PC_2,label=Country))+
geom_point()+
geom_text(hjust = 0, nudge_x = 1)+
xlim(c(-25,45)) +
xlab("Score of Principle Component 1") +
ylab("Score of Principle Component 2")
#### PC of Derivatives ####
derivs <- deriv.fd(sample_of_functions,Lfdobj = 1)
eval_df_derivs <- as.data.frame(eval.fd(year_mesh,derivs)) %>%
mutate(Year=year_mesh)
eval_df_derivs_long <- pivot_longer(eval_df_derivs,names_to = "Country",values_to = "MortalityRate",cols=1:4)
# gives visualisation of sample of functions
ggplot(eval_df_derivs_long,aes(x=Year,y=MortalityRate,col=Country))+
geom_line()+
ylab("Change in Age-standardised death rates per 100,000 people")
principle_components_of_derivs <- pca.fd(derivs)
func_eval_derivs <- eval.fd(year_mesh,principle_components_of_derivs$harmonics)
PC_DF_derivs <- data.frame(
Year = year_mesh,
PC_1 = func_eval_derivs[,1],
PC_2 = func_eval_derivs[,2]
)
ggplot(PC_DF_derivs,aes(x=Year,y=PC_1))+
geom_line() +
ylab("Principal Component Function 1")
ggplot(PC_DF_derivs,aes(x=Year,y=PC_2))+
geom_line()
scores_df_derivs <- data.frame(
PC_1 = principle_components_of_sample$scores[,1],
PC_2 = principle_components_of_sample$scores[,2],
Country=colnames(observation_matrix)
)
ggplot(scores_df_derivs,aes(x=PC_1,y=PC_2,label=Country))+
geom_point()+
geom_text(hjust = 0, nudge_x = 1)+
xlim(c(-25,45)) +
xlab("Score of Principle Component 1") +
ylab("Score of Principle Component 2")
#### Individually Fitting Functions ####
fit_individ_func <- function(time_points,obs_matrix,basis){
rep_dims <-  colnames(obs_matrix)
for (i in 1:ncol(obs_matrix)){
dim_i <- rep_dims[i]
optimised_function <- optimise(GCV_func,lower=0,upper=10,basis=basis,observations=obs_matrix[,i],time_points=time_points,penalty=2)
minimum_log_lambda <- optimised_function$minimum
minimum_lambda <- 10^minimum_log_lambda
fd_par_obj <- fdPar(basis,2,minimum_lambda)
fd_obj <- smooth.basis(time_points,obs_matrix[,i],fd_par_obj)$fd
coefs_i <- fd_obj$coefs
colnames(coefs_i) <- dim_i
if (i==1){
coefs <- coefs_i
} else{
coefs <- cbind(coefs, coefs_i)
}
}
merged_fd <- fd(coef = coefs, basisobj =basis)
merged_fd$fdnames$reps <- rep_dims
return(merged_fd)
}
ind_fit_funcs <- fit_individ_func(Years,observation_matrix,basis_mortality_rates)
eval_df_indv <- as.data.frame(eval.fd(year_mesh,ind_fit_funcs)) %>%
mutate(Year=year_mesh)
eval_df_indv_long <- pivot_longer(eval_df_indv,names_to = "Country",values_to = "MortalityRate",cols=1:4)
# gives visualisation of sample of functions
ggplot(mortality_rates_long,aes(x=Year,y=MortalityRate,col=Country))+
geom_point()+
ylab("Age-standardised death rates per 100,000 people")
ggplot(eval_df_indv_long,aes(x=Year,y=MortalityRate,col=Country))+
geom_line()+
geom_point(data=mortality_rates_long,aes(x=Year,y=MortalityRate,col=Country),inherit.aes = FALSE,alpha=0.2)+
ylab("Age-standardised death rates per 100,000 people")
residuals_matrix <- eval.fd(Years,ind_fit_funcs)-observation_matrix
apply(t(residuals_matrix),1,shap_test)
#### Individually Fit Functions PCA ####
principle_components_of_sample_ind <- pca.fd(ind_fit_funcs)
func_eval_ind <- eval.fd(year_mesh,principle_components_of_sample_ind$harmonics)
PC_DF_ind <- data.frame(
Year = year_mesh,
PC_1 = func_eval_ind[,1],
PC_2 = func_eval_ind[,2]
)
ggplot(PC_DF_ind,aes(x=Year,y=PC_1))+
geom_line() +
ylab("Principal Component Function 1")+
ggtitle(paste0("PC 1 - Explains ",100*principle_components_of_sample_ind$varprop[1],"% Of Variation"))
ggplot(PC_DF_ind,aes(x=Year,y=PC_2))+
geom_line() +
ylab("Principal Component Function 2")+
ggtitle(paste0("PC 2 - Explains ",100*principle_components_of_sample_ind$varprop[2],"% Of Variation"))
scores_df_ind <- data.frame(
PC_1 = principle_components_of_sample_ind$scores[,1],
PC_2 = principle_components_of_sample_ind$scores[,2],
Country=colnames(observation_matrix)
)
ggplot(scores_df_ind,aes(x=PC_1,y=PC_2,label=Country))+
geom_point()+
geom_text(hjust = 0, nudge_x = 1)+
xlim(c(-25,45)) +
xlab("Score of Principle Component 1") +
ylab("Score of Principle Component 2")
#### Load in Unemployment Data ####
Scot_UnE <- read.csv("Scotland Unemployment.csv",skip=7) %>%
rename("Year"=Important.notes,"Unemployment_Rate"=X) %>%
filter(Year %in% Years) %>%
mutate(Year=as.numeric(Year)) %>%
mutate(Country="Scotland")
Eng_UnE <- read.csv("England Unemployment.csv",skip=7) %>%
rename("Year"=Important.notes,"Unemployment_Rate"=X) %>%
filter(Year %in% Years) %>%
mutate(Year=as.numeric(Year)) %>%
mutate(Country="England")
Wales_UnE <- read.csv("Wales Unemployment.csv",skip=7) %>%
rename("Year"=Important.notes,"Unemployment_Rate"=X) %>%
filter(Year %in% Years) %>%
mutate(Year=as.numeric(Year)) %>%
mutate(Country="Wales")
NI_UnE <- read.csv("Northern Ireland Unemployment.csv",skip=7) %>%
rename("Year"=Important.notes,"Unemployment_Rate"=X) %>%
filter(Year %in% Years) %>%
mutate(Year=as.numeric(Year)) %>%
mutate(Country="Northern Ireland")
All_Countries_UnE <- bind_rows(Scot_UnE,Eng_UnE,Wales_UnE,NI_UnE)
All_Countries_UnE_Wide <- pivot_wider(All_Countries_UnE,names_from = Country,values_from = Unemployment_Rate)
#### Function Fitting ####
Years_UnE <- unique(All_Countries_UnE$Year)
basis_UnE <- create.bspline.basis(range(Years_UnE),
breaks=Years_UnE,
norder=4)
observation_matrix_UnE <- data.matrix(All_Countries_UnE_Wide[,c(-1)])
optimised_function_UnE <- optimise(GCV_func,lower=0,upper=10,basis=basis_UnE,observations=observation_matrix_UnE,time_points=Years_UnE,penalty=2)
minimum_log_lambda_UnE <- optimised_function_UnE$minimum
minimum_lambda_UnE <- 10^minimum_log_lambda_UnE
fd_par_obj_UnE <- fdPar(basis_UnE,2,minimum_lambda_UnE)
sample_of_functions_UnE <- fit_individ_func(Years_UnE,observation_matrix_UnE,basis_UnE)
sample_of_functions_UnE$fdnames$time <- "Years"
sample_of_functions_UnE$fdnames$values <- "Unemployment Rate"
eval_df_UnE <- as.data.frame(eval.fd(year_mesh,sample_of_functions_UnE)) %>%
mutate(Year=year_mesh)
eval_df_long_UnE <- pivot_longer(eval_df_UnE,names_to = "Country",values_to = "Unemployment_Rate",cols=1:4)
# gives visualisation of sample of functions
ggplot(All_Countries_UnE,aes(x=Year,y=Unemployment_Rate,col=Country))+
geom_point()+
ylab("Unemployment Rate %")
ggplot(eval_df_long_UnE,aes(x=Year,y=Unemployment_Rate,col=Country))+
geom_line()+
geom_point(data=All_Countries_UnE,aes(x=Year,y=Unemployment_Rate,col=Country),inherit.aes = FALSE,alpha=0.2)+
ylab("Unemployment Rate %")
#### Checking Residuals ####
shap_test <- function(vector){
shapiro.test(vector)$p.value
}
residuals_matrix <- eval.fd(Years_UnE,sample_of_functions_UnE)-observation_matrix_UnE
apply(t(residuals_matrix),1,shap_test)
#### PC Analysis of Unemployment ####
principle_components_of_sample_UnE <- pca.fd(sample_of_functions_UnE)
func_eval_UnE <- eval.fd(year_mesh,principle_components_of_sample_UnE$harmonics)
PC_DF_UnE <- data.frame(
Year = year_mesh,
PC_1 = func_eval_UnE[,1],
PC_2 = func_eval_UnE[,2]
)
ggplot(PC_DF_UnE,aes(x=Year,y=PC_1))+
geom_line() +
ylab("Principal Component Function 1")+
ggtitle(paste0("PC 1 - Explains ",100*principle_components_of_sample_UnE$varprop[1],"% Of Variation"))
ggplot(PC_DF_UnE,aes(x=Year,y=PC_2))+
geom_line() +
ylab("Principal Component Function 2")+
ggtitle(paste0("PC 2 - Explains ",100*principle_components_of_sample_UnE$varprop[2],"% Of Variation"))
scores_df_UnE <- data.frame(
PC_1 = principle_components_of_sample_UnE$scores[,1],
PC_2 = principle_components_of_sample_UnE$scores[,2],
Country=colnames(observation_matrix_UnE)
)
ggplot(scores_df_UnE,aes(x=PC_1,y=PC_2,label=Country))+
geom_point()+
geom_text(hjust = 0, nudge_x = 0.08)+
xlim(c(-3,2))+
xlab("Score of Principle Component 1") +
ylab("Score of Principle Component 2")
Countries <- unique(mortality_rates_long$Country)
coefficients <- cbind(sample_of_functions$coefs,0)
coefficients
colnames(sample_of_functions$coefs)
sample_of_functions_regression <- fd(coefficients,basis_mortality_rates,colnames(sample_of_functions$coefs))
sample_of_functions_regression
plot(sample_of_functions_regression)
sample_of_functions_regression
sample_of_functions_regression <- fd(coefficients,basis_mortality_rates,sample_of_functions$fdnames)
sample_of_functions_regression
plot(sample_of_functions_regression)
coefficients <- cbind(sample_of_functions_UnE$coefs,0)
sample_of_functions_regression <- fd(coefficients,basis_UnE,sample_of_functions_UnE$fdnames)
sample_of_functions_regression
beta_basis <- basis_UnE
beta_fdPar <- fdPar(beta_basis)
beta_list <- vector("list",5)
beta_list
beta_list <- list()
beta_fdPar <- fdPar(beta_basis)
beta_list <- list()
for (i in 1:nrows(coefficients)){
beta_list[[i]] <- beta_fdPar
}
for (i in 1:nrow(coefficients)){
beta_list[[i]] <- beta_fdPar
}
beta_list
beta_list[[1]]
beta_list <- list()
for (i in 1:ncol(coefficients)){
beta_list[[i]] <- beta_fdPar
}
beta_list[[1]]
list_covariate <- list(rep(1,39),sample_of_functions_UnE)
list_covariate
list_covariate <- list(rep(1,Years),sample_of_functions_UnE)
list_covariate <- list(rep(1,length(Years)),sample_of_functions_UnE)
beta_fdPar <- fdPar(basis_mortality_rates,2)
list_covariate <- list(rep(1,length(Years)),sample_of_functions_UnE)
beta_fdPar <- fdPar(basis_mortality_rates,2)
beta_list <- list(beta_fdPar,beta_fdPar)
fRegress(sample_of_functions,list_covariate,beta_list)
list_covariate <- list(rep(1,length(Countries)),sample_of_functions_UnE)
beta_fdPar <- fdPar(basis_mortality_rates,2)
beta_list <- list(beta_fdPar,beta_fdPar)
fRegress(sample_of_functions,list_covariate,beta_list)
functional_regression <- fRegress(sample_of_functions,list_covariate,beta_list)
list_covariate <- list(rep(1,length(Countries)),sample_of_functions_UnE)
beta_fdPar <- fdPar(basis_mortality_rates,2)
beta_list <- list(beta_fdPar,beta_fdPar)
functional_regression <- fRegress(sample_of_functions,list_covariate,beta_list)
functional_regression$betaestlist
plot(functional_regression$betaestlist)
plot(functional_regression)
plot.fd(functional_regression)
plot.fd(functional_regression$yfdobj)
par(mfrow=c(1,1))
plot.fd(functional_regression)
plot.fd(functional_regression$betalist)
plot.fd(functional_regression$betaestlist)
plot.fd(functional_regression$xfdlist)
plot.fd(functional_regression$yfdlist)
plot.fd(functional_regression$yfdobj)
plot.fd(functional_regression$yhatfdobj)
estimate_of_response <- functional_regression$yhatfdobj
beta_ests <- functional_regression$betaestlist
beta_ests
beta <- functional_regression$betaestlist[[2]]
beta
beta <- functional_regression$betaestlist[[2]]$fd
plot(beta)
plotbeta(functional_regression)
stderrList <- fRegress.stderr(sample_of_functions,list_covariate,beta_list)
stderrList <- fRegress.stderr(sample_of_functions,functional_regression$y2cMap,beta_list)
